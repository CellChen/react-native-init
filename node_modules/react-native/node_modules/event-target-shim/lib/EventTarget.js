"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = EventTarget;

var _commons = require("./commons");

var _CustomEventTarget = require("./CustomEventTarget");

var _EventWrapper = require("./EventWrapper");

var HAS_EVENTTARGET_INTERFACE = typeof window !== "undefined" && typeof window.EventTarget !== "undefined";

function EventTarget() {
  for (var _len = arguments.length, types = Array(_len), _key = 0; _key < _len; _key++) {
    types[_key] = arguments[_key];
  }

  if (this instanceof EventTarget) {
    // this[LISTENERS] is a Map.
    // Its key is event type.
    // Its value is ListenerNode object or null.
    //
    // interface ListenerNode {
    //   let listener: Function
    //   let kind: CAPTURE|BUBBLE|ATTRIBUTE
    //   let next: ListenerNode|null
    // }
    Object.defineProperty(this, _commons.LISTENERS, { value: Object.create(null) });
  } else if (types.length > 0) {
    // To use to extend with attribute listener properties.
    // e.g.
    //     class MyCustomObject extends EventTarget("message", "error") {
    //       //...
    //     }
    return (0, _CustomEventTarget.defineCustomEventTarget)(EventTarget, types);
  } else {
    throw new TypeError("Cannot call a class as a function");
  }
}

EventTarget.prototype = Object.create((HAS_EVENTTARGET_INTERFACE ? window.EventTarget : Object).prototype, {
  constructor: {
    value: EventTarget,
    writable: true,
    configurable: true
  },

  addEventListener: {
    value: function addEventListener(type, listener) {
      var capture = arguments[2] === undefined ? false : arguments[2];

      if (listener == null) {
        return false;
      }
      if (typeof listener !== "function") {
        throw new TypeError("listener should be a function.");
      }

      var kind = capture ? _commons.CAPTURE : _commons.BUBBLE;
      var node = this[_commons.LISTENERS][type];
      if (node == null) {
        this[_commons.LISTENERS][type] = (0, _commons.newNode)(listener, kind);
        return true;
      }

      var prev = null;
      while (node != null) {
        if (node.listener === listener && node.kind === kind) {
          // Should ignore a duplicated listener.
          return false;
        }
        prev = node;
        node = node.next;
      }

      prev.next = (0, _commons.newNode)(listener, kind);
      return true;
    },
    configurable: true,
    writable: true
  },

  removeEventListener: {
    value: function removeEventListener(type, listener) {
      var capture = arguments[2] === undefined ? false : arguments[2];

      if (listener == null) {
        return false;
      }

      var kind = capture ? _commons.CAPTURE : _commons.BUBBLE;
      var prev = null;
      var node = this[_commons.LISTENERS][type];
      while (node != null) {
        if (node.listener === listener && node.kind === kind) {
          if (prev == null) {
            this[_commons.LISTENERS][type] = node.next;
          } else {
            prev.next = node.next;
          }
          return true;
        }

        prev = node;
        node = node.next;
      }

      return false;
    },
    configurable: true,
    writable: true
  },

  dispatchEvent: {
    value: function dispatchEvent(event) {
      // If listeners aren't registered, terminate.
      var node = this[_commons.LISTENERS][event.type];
      if (node == null) {
        return true;
      }

      // Since we cannot rewrite several properties, so wrap object.
      event = (0, _EventWrapper.createEventWrapper)(event, this);

      // This doesn't process capturing phase and bubbling phase.
      // This isn't participating in a tree.
      while (node != null) {
        node.listener.call(this, event);
        if (event[_EventWrapper.STOP_IMMEDIATE_PROPAGATION_FLAG]) {
          break;
        }
        node = node.next;
      }

      return !event.defaultPrevented;
    },
    configurable: true,
    writable: true
  }
});
module.exports = exports["default"];